import { create } from "zustand";
import { save, load } from "../utils/storage";

export type Note = {
  id: string;                   // unique note id (generated by the store)
  title: string;                // title of note
  body: string;                 // body / content
  imageUri?: string | null;     // optional image uri (local or file://)
  updatedAt: number;            // last updated timestamp (ms)
  createdAt: number;            // created timestamp (ms)
};

// store state + actions
type NotesState = {
  notes: Note[];                  
  loading: boolean;                
  loadNotesForUser: (userId: string) => Promise<void>;
  addNote: (
    userId: string,
    note: Omit<Note, "id" | "createdAt" | "updatedAt">
  ) => Promise<Note>;
  updateNote: (userId: string, note: Note) => Promise<Note | null>;
  // delete a note
  deleteNote: (userId: string, noteId: string) => Promise<boolean>;
  clear: () => void;
};

const NOTES_KEY_PREFIX = "NOTES_";  

const makeKey = (userId: string) => `${NOTES_KEY_PREFIX}${userId}_V1`;

// create Zustand store
export const useNotesStore = create<NotesState>((set, get) => ({
  notes: [],
  loading: false,

  loadNotesForUser: async (userId: string) => {
    set({ loading: true });
    try {
      const key = makeKey(userId);
      const stored = await load<Note[]>(key); // load helper returns parsed JSON 
      set({ notes: stored ?? [], loading: false });
    } catch (err) {
      console.error("notesStore.loadNotesForUser err:", err);
      set({ notes: [], loading: false });
    }
  },

  // add a note for the given userId
  addNote: async (userId, noteData) => {
    set({ loading: true });
    try {
      const key = makeKey(userId);
      // load current user's notes (or empty array)
      const current = (await load<Note[]>(key)) ?? [];
      const now = Date.now();
      // create the note object here (store generates id & timestamps)
      const newNote: Note = {
        id: Math.random().toString(36).slice(2, 9),
        title: noteData.title,
        body: noteData.body,
        imageUri: noteData.imageUri ?? null,
        createdAt: now,
        updatedAt: now,
      };
      const updated = [newNote, ...current];
      await save(key, updated); // persist updated array
      set({ notes: updated, loading: false });
      return newNote;
    } catch (err) {
      console.error("notesStore.addNote err:", err);
      set({ loading: false });
      throw err;
    }
  },

  // update existing note (note.id must exist)
  updateNote: async (userId, note) => {
    set({ loading: true });
    try {
      const key = makeKey(userId);
      const current = (await load<Note[]>(key)) ?? [];
      const idx = current.findIndex((n) => n.id === note.id);
      if (idx === -1) {
        set({ loading: false });
        return null; // not found
      }
      const updatedNote: Note = {
        ...current[idx],
        title: note.title,
        body: note.body,
        imageUri: note.imageUri ?? null,
        updatedAt: Date.now(),
      };
      // keep newest-to-top: remove old and unshift new
      const updated = [...current];
      updated.splice(idx, 1);
      updated.unshift(updatedNote);

      await save(key, updated);
      set({ notes: updated, loading: false });
      return updatedNote;
    } catch (err) {
      console.error("notesStore.updateNote err:", err);
      set({ loading: false });
      throw err;
    }
  },

  // delete a note for the user
  deleteNote: async (userId, noteId) => {
    set({ loading: true });
    try {
      const key = makeKey(userId);
      const current = (await load<Note[]>(key)) ?? [];
      const updated = current.filter((n) => n.id !== noteId);
      await save(key, updated);
      set({ notes: updated, loading: false });
      return true;
    } catch (err) {
      console.error("notesStore.deleteNote err:", err);
      set({ loading: false });
      return false;
    }
  },

  clear: () => set({ notes: [] }),
}));

export default useNotesStore;
